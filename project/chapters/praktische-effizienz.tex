\chapter{Laufzeitermittlung als Effizienzangabe}

In diesem Kapitel wird eine Methode zur Ermittlung der Laufzeit von Algorithmen dargestellt.

Es gilt die Laufzeit eines Algorithmus zu ermitteln und diese annähernd als Funktion $T(n)$ (wobei $T(n)$ die Zeit und $n$ die Eingabegröße ist) darzustellen. Das Ziel deckt sich also mit jenem der asymptotischen Analyse aus \prettyref{cha:asymptotic-analysis}. Genauer gilt es, ebenfalls wie in der asymptotischen Analyse, eine solche Funktion für diverse Arten von Eingabemengen zu ermitteln (\cite[27]{mcg2012}).

Nach \cite[10]{mcg2012} kann \enquote{the experimental process} im Kontext der empirischen Algorithmusanalyse im Wesentlichen grob in folgende vier Schritte aufgegliedert werden.

\begin{enumerate}
     \item Formuliere eine Frage.\label{itm:experiment-formulate-question}
     \item Stelle eine Testumgebung bereit.\label{itm:experiment-environment}
     \item Gestalte ein Experiment welches die Frage aus \prettyref{itm:experiment-formulate-question} anspricht.
     \item Führe das Testprogramm aus und sammle die Daten.
 \end{enumerate}

Eine grobe Formulierung der Frage ergibt sich schon aus der vorhergehenden Einleitung dieses Kapitels:

\spaced{\enquote{Wie viel Zeit benötigt ein Sortieralgorithmus um Eingabemengen verschiedener Art und Größe in eine sortierte Ausgabemenge zu überführen?}}

Um diese Frage umsetzbar zu machen, gilt es nunmehr nur noch die verschiedenen Arten und Größen der Eingabemengen zu definieren, dies geschieht in \prettyref{sec:runtime-inputs}, und eine Testumgebung bereitzustellen, dies geschieht in \prettyref{sec:runtime-environment}.

\ifndef{vwarelease}{
\emph{Hier sind \citetitle{joh2002} (\cite{joh2002}) und \citetitle{mcg2012} (\cite{mcg2012}) wichtig. \cite[83]{sha2011} kann als Argumentation für das ausgeprägte Verwenden der \emph{Standard Library} ausgelegt werden nachdem hier potentielle Vorurteile bzw. Ungleichheiten bei der Programmierung de facto wegfallen.}

\emph{Der Werdegang der Empirie in den Computerwissenschaften ist nicht unspannend: Zu Zeiten von \cite{joh2002} war die empirische Analyse als Feld offenbar noch bei weitem nicht so weit fortgeschritten und verbreitet wie im Erscheinungsjahr von \cite{mcg2012}. Beide beinhalten weitgehend äquivalente Kernaussagen, aber erstere Publikation ist noch bei weitem unausgereifter als letztere. 
}}{}

\section{Eingabemengen}
\label{sec:runtime-inputs}

\ifndef{vwarelease}{\emph{Referenzen anderer Analysen mit gleichen oder überlappenden Eingabearten sind beizufügen.}}{}

Für die Ermittlung der praktischen Effizienz werden
\begin{enumerate}[nosep]
    \item sortierte
    \item invertierte
    \item zufällig geordnete
\end{enumerate}
Eingabemengen verwendet.

Siehe \prettyref{lst:sets} für eine beispielhafte Implementation von Generatoren der obigen Eingabemengearten.

Eine ausführlichere Auswahl an Eingangsmengen welche an einen sie bearbeitenden Algorithmen angepasst ist --- wie sie für eine eingehende Analyse eines einzelnen Algorithmus angebracht wäre --- würde das allgemeiner gesetzte Ziel dieser Arbeit verfehlen (vgl. \cite[27ff]{mcg2012}).

\section{Testumgebung}
\label{sec:runtime-environment}

Ein Algorithmus wird ausgeführt, die Zeit unmittelbar vor (\id{start}) und nach (\id{end}) der Ausführung wird gemessen. Die Laufzeit des Algorithmus ist nun gleich $\id{end} - \id{start}$.

Eine konkrete Implementation einer Klasse zur Messung der Laufzeit eines Algorithmus ist in \prettyref{lst:experiment} gegeben. \ifndef{vwarelease}{\emph{Referenzen zu empirischen Analysen die einen ähnlichen Mechanismus zur Laufzeitermittlung verwenden (kann nicht so schwer sein, was sollen sie sonst verwenden) sind beizufügen.}}{}

\begin{lstlisting}[caption={Implementation einer Klasse zur Ermittlung der Laufzeit eines Algorithmus.}, label=lst:experiment]
class experiment {
	std::function<void()> algorithm;

public:
	using time_t = double;

	|\label{ln:exp-constructor}|explicit experiment(std::function<void()> algorithm)
		: algorithm(std::move(algorithm)) { };

	auto run() const {
		const auto |\id{start}| = std::chrono::steady_clock::now();

		algorithm();

		const auto |\id{end}| = std::chrono::steady_clock::now();

		return std::chrono::duration<time_t, std::micro>{ |\id{end}| - |\id{start}| };
	}
};
\end{lstlisting}

Die Laufzeit eines einfachen Algorithmus kann mit ihrer Hilfe durch
\begin{lstlisting}[numbers=none]
void a1() { ... }
const auto time = experiment(a1).run();
\end{lstlisting}
ermittelt werden, wobei die Zeitspanne in Mikrosekunden ($1\mu s = 10^{-6} s$) angegeben ist.

\paragraph{Algorithmen mit Eingabewerten} Der Konstruktor in \prettyref{lst:experiment}, \prettyref{ln:exp-constructor} erwartet als einzige Eingabe eine Variable des Typs \lstinline{std::function<void()>}, also eine Funktion ohne Eingabe- und Rückgabewerte. Dies ist der Fall um größtmögliche Flexibilität in der Verwendung der Testumgebung zu gewährleisten.

Die in dieser Arbeit behandelten Algorithmen haben alle einen oder mehrere Eingabewerte, sie erfüllen also nicht die Form wie sie vom Konstruktor erwartet wird. Um ein Experiment mit einer Funktion eines anderen Typs als \lstinline{void()} zu initialisieren wird ein \enquote{\emph{wrapper}} verwendet:

\begin{lstlisting}[numbers=none]
void |\id{func}|(size_t s) { ... }
const auto |\id{wrapper}| = std::bind(func, 1337);
const auto time = experiment(wrapper).run();
\end{lstlisting}

Im obenstehenden Beispielcode wird die Funktion \lstinline{std::bind} der Standardbibliothek verwendet um eine \enquote{umwickelnde Funktion} \id{wrapper} (des Typs \lstinline{void()}) zu erstellen. Ein Aufruf von \id{wrapper} führt zum Aufruf der Funktion \id{func} mit dem Eingabeparameter 1337 (wie durch die an \lstinline{std::bind} übergebenen Parametern festgelegt wurde).

\section{Funktionsermittlung}
\label{sec:funkterm}

Im gegebenen Kontext ist es das Ziel der \enquote{Funktionsermittlung} eine Funktion in Abhängigkeit der Eingabegröße aufzustellen bzw. zu approximieren, welche die Laufzeit darstellt (vgl. \cite[37]{mcg2012} --- \emph{Modeling}).

Werte dieser Funktion der praktischen Effizienz können mithile der Funktion \lstinline{benchmark::run} in \prettyref{lst:benchmark} ermittelt werden.

\begin{lstlisting}[label=lst:benchmark, caption={Implementation einer Funktion zur Ermittlung der praktischen Effizienz eines Algorithmus mit einer bestimmenten Eingabemenge.}]
namespace benchmark {
	using timings_t = std::map<size_t, experiment::time_t>;

	template<class A, class S>
	timings_t run(A algorithm, S set, int total_chunks) {
		timings_t timings;

		const size_t set_size = set.size();

		std::fesetround(FE_TONEAREST);

		const size_t chunk_size = set_size > total_chunks ?
			std::nearbyint(set_size / total_chunks) : 1;

		for (size_t i = chunk_size; i <= set_size; i += chunk_size) {
			auto subset = S(set.begin(), set.begin() + i);
			const auto time = experiment(std::bind(algorithm,
				subset.begin(), subset.end(), std::less<>())
			).run();

			timings.emplace(i, time.count());
		}

		return timings;
	}
	
	...
}
\end{lstlisting}

Die Funktion \lstinline{benchmark::run} nimmt als Eingabeparameter einen Algorithmus, eine Menge und die Anzahl der Untermengen.

Nach Ausführung von \lstinline{benchmark::run} werden (sequentiell) \emph{überlappende Untermengen} der Eingabemenge erstellt. Für jede Untermenge wird eine Instanz der Experimentklasse (siehe \prettyref{sec:runtime-environment}) erstellt und ausgeführt, somit wird für jede Untermenge die Laufzeit des Algorithmus ermittelt.

Als Rückgabewert liefert sie Wertepaare in einem \emph{Container} vom Typ \lstinline{std::map<size_t, experiment::time_t>}. Dieser assoziative Container enthält eine geordnete Menge von Schlüssel-Wert-Paaren wobei die Schlüssel die Größe der jeweils betrachteten und sortierten Untermenge, und die Werte die jeweils benötigten Zeiten darstellen. Die Werte können nun wie in \prettyref{subfig:funkterm-beispieldaten} ausgegeben, oder wie in \prettyref{subfig:funkterm-beispielgraph} als Graph dargestellt werden.

\input{figures/function-determination-raw-data}

Der Prägnanz halber wird es hilfreich sein einige der im vorhergehenden Quellcode vorkommende Variablennamen Pseudonyme zu geben. Ebenfalls werden dem Verständnis dienende \enquote{gedachte Variablen} benannt. So gilt folgend
%
\begin{equation*}
	\begin{aligned}
		t &= \text{\lstinline{total_chunks}, Anzahl der Untermengen} \\
		s &= \text{\lstinline{set_size}, Größe der Eingabemenge} \\
		c &= \text{\lstinline{chunk_size}, \enquote{Schrittgröße}} \\
		t &= \text{Anzahl der Untermengen} \\
		U_i &= \text{$i$-te Untermenge} \\
		n_i &= \text{Größe von $U_i$} \\
	\end{aligned}
\end{equation*}
%
Die Anzahl der Untermengen und die Größe der Eingabemenge ist bekannt. Um nun die Größe der jeweilige Untermengen zu berechnen gilt
\begin{equation*}
	n_i = c \cdot i \quad \text{für alle $0 < i \leq \frac{s}{c} \in \mathbb{N}$}
\end{equation*}
für
\begin{equation*}
	c = \begin{cases}
		1 & \text{für $s \leq t$}\\
		\frac{s}{t} & \text{für $s > t$}
	\end{cases} \in \mathbb{N}
\end{equation*}

Sollen aus einer Eingangsmenge der Größe 100 insgesamt 30 Untermengen generiert werden, gilt $c = 3$ (nicht $3,\overline{3}$ nachdem $c \in \mathbb{N}$) und somit $n_1 = 3, n_2 = 6, \ldots, n_{33} = 99$. \emph{Hier gilt also, dass das größtmögliche $i \neq t$!} Es werden in manchen Fällen mehr Untermengen generiert als angefordert, wenn dies möglich ist. Im gegebenen Verwendungsfall ist das vorteilhaft und Absicht, der Umstand ist dennoch erwähnenswert um Verwirrung vorzubeugen.

\section{Orchestrierung}

In den vorhergehenden Abschnitten wurde

\begin{itemize}
    \item eine Definition für einige Eingabemengen mit ihren korrespondierenden Generatoren gegeben (\prettyref{sec:runtime-inputs}).
    \item eine Testumgebung (\lstinline{class experiment}) zur Ermittlung der Laufzeit eines Algorithmus mit einer bestimmten Eingabemenge und Größe (\prettyref{sec:runtime-environment}).
    \item einen Mechanismus zur Laufzeitermittlung für steigende bzw. variierende Eingabegrößen (\lstinline{namespace benchmark}, \prettyref{sec:funkterm}).
\end{itemize}

Noch abgehend ist ein Mechanismus zur \emph{Orchestrierung} bzw. \emph{Instrumentalisierung} der bestehenden Teile. Genauer gilt es ein ausführbares Programm bereitzustellen, welches

\begin{itemize}
    \item mithilfe von \lstinline{benchmark::run} für alle möglichen Kombinationen aus den Algorithmen und Eingabearten Wertepaare ermittelt, und diese Wertepaare in weiterverarbeitbarer Form ausgibt.

    \item einen Mechanismus zur Kontrolle des Umfangs und der Präzision von Messungen bietet.
\end{itemize}

\begin{lstlisting}[label=lst:main, caption={Die \lstinline{main} Funktion des zur Ermittlung der praktischen Effizienz verwendeten Programms.}]
int main(int, char *argv[]) {
	config cfg{argv};

	if (cfg.should_exit) {
		return 1;
	}

	auto sorters = std::map<const char *, algorithm_t>{
		{"quick",       sorters::quick<sets::iterator_t>},
		{"heap",        sorters::heap<sets::iterator_t>},
		{"merge",       sorters::merge<sets::iterator_t>},
		{"insertion",   sorters::insertion<sets::iterator_t>},
	};

	const size_t set_size = cfg.sample_size;

	auto sets = std::map<const char *, sets::set_t>{
		{"sorted",      sets::sorted(set_size)},
		{"random",      sets::random(set_size)},
		{"inverted",    sets::inverted(set_size)},
	};

	printf("sorting %d elements\n", set_size);

	for (auto [sorter_name, sorter] : sorters) {
		for (auto [set_name, set] : sets) {
			benchmark::write(cfg.output, sorter_name, set_name,
				benchmark::run(sorter, set, cfg.total_chunks));
		}
	}

	return 0;
}
\end{lstlisting}

\prettyref{lst:main} zeigt eine Implementation der obigen Anforderungen. Die Algorithmen werden gesammelt und mit einem ausgebbaren Namen assoziiert, ebenso die Eingabemengen. Jeder Algorithmus wird mit jeder Eingabemenge kombiniert und an \lstinline{benchmark::run} übergeben, das Ergebnis wird durch \lstinline{benchmark::write} (siehe \prettyref{lst:benchmark-write}) abgelegt.

\prettyref{fig:benchmark-file-structure} demonstriert beispielhaft die Art und Weise mit welcher die Funktion in \prettyref{lst:main} Daten ablegt.

\input{figures/benchmark-file-structure}
