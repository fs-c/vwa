\chapter{Laufzeitermittlung als Effizienzangabe}
\label{cha:praktische-effizienz}

In diesem Kapitel wird eine Methode zur Ermittlung der Laufzeit von Algorithmen dargestellt.

Für konkrete Implementationen und Quellcode-Beispiele wird die Programmiersprache C++ (\cite{ISO-C++17}, \enquote{C++17}) verwendet.

\ifndef{vwarelease}{
\emph{Hier sind \citetitle{joh2002} (\cite{joh2002}) und \citetitle{mcg2012} (\cite{mcg2012}) wichtig. \cite[83]{sha2011} kann als Argumentation für das ausgeprägte Verwenden der \emph{Standard Library} ausgelegt werden nachdem hier potentielle Vorurteile bzw. Ungleichheiten bei der Programmierung de facto wegfallen.}

\emph{Der Werdegang der Empirie in den Computerwissenschaften ist nicht unspannend: Zu Zeiten von \cite{joh2002} war die empirische Analyse als Feld offenbar noch bei weitem nicht so weit fortgeschritten und verbreitet wie im Erscheinungsjahr von \cite{mcg2012}. Beide beinhalten weitgehend äquivalente Kernaussagen, aber erstere Publikation ist noch bei weitem unausgereifter als letztere. 
}}{}

\section{Vorgehensweise}

Es gilt die Laufzeit eines Algorithmus zu ermitteln und diese annähernd als Funktion $T(n)$ (wobei $T(n)$ die Zeit und $n$ die Eingabegröße ist) darzustellen. Das Ziel deckt sich also mit jenem der asymptotischen Analyse aus \prettyref{cha:asymptotic-analysis}. Genauer gilt es, ebenfalls wie in der asymptotischen Analyse, eine solche Funktion für diverse Arten von Eingabemengen zu ermitteln (\cite[27]{mcg2012}).

Nach \cite[10]{mcg2012} kann \enquote{the experimental process} im Kontext der empirischen Algorithmusanalyse im Wesentlichen grob in die Formulierung einer Frage, die Bereitstellung einer, die Frage behandelnden, Testumgebung bzw. eines Testprogramms und die Ausführung des Testprogramms aufgegliedert werden.

Eine grobe Formulierung der Frage ergibt sich schon aus der vorhergehenden Einleitung dieses Kapitels:

\spaced{\enquote{Wie viel Zeit benötigt ein Sortieralgorithmus um Eingabemengen verschiedener Art und Größe in eine sortierte Ausgabemenge zu überführen?}}

Um diese Frage zu konkretisieren und umsetzbar zu machen, gilt es nunmehr noch die verschiedenen Arten und Größen der Eingabemengen zu definieren, dies geschieht in \prettyref{sec:runtime-inputs}.

Eine Testumgebung welche die Frage behandelt wird in \prettyref{sec:runtime-environment} bereitgestellt.

\section{Eingabemengen}
\label{sec:runtime-inputs}

Für die Ermittlung der praktischen Effizienz werden sortierte, invertierte und zufällig geordnete Eingabemengen verwendet. Um diese Mengen zu generieren werden die Funktionen \lstinline{sets::sorted}, \lstinline{sets::inverted} und \lstinline{sets::random} verwendet.

\begin{lstlisting}[caption=Funktionen welche Mengen der verwendeten Eingabemengearten generieren.]
namespace sets {
    using set_t = std::vector<int>;

    // ...
}

sets::set_t sets::sorted(const size_t size) {
	auto set = set_t(size);

	std::iota(set.begin(), set.end(), 1);

	return set;
}

sets::set_t sets::inverted(const size_t size) {
	auto set = set_t(size);

	std::iota(std::rbegin(set), std::rend(set), 1);

	return set;
}

sets::set_t sets::random(const size_t size) {
	auto set = sorted(size);

	utils::random_shuffle(set.begin(), set.end());

	return set;
}
\end{lstlisting}

(Die Funktion \lstinline{utils::random_shuffle}, welche für das Generieren der zufällig geordneten Menge verwendet wird, verwendet den Mersenne-Twister Algorithmus um hochwertige Pseudozufallszahlen zu generieren und damit die Eingabemenge \enquote{durchzumischen}. Siehe \prettyref{lst:random-shuffle} für die verwendete Implementation der Funktion.)

Eine ausführlichere Auswahl an Eingangsmengen welche an einen sie bearbeitenden Algorithmen angepasst ist --- wie sie für eine eingehende Analyse eines einzelnen Algorithmus angebracht wäre (vgl. \cite[27ff]{mcg2012}) --- würde das allgemeiner gesetzte Ziel dieser Arbeit verfehlen.

\section{Testumgebung}
\label{sec:runtime-environment}

Es gilt die Zeit, welche eine Funktion für die vollständige Ausführung benötigt, zu messen. Die Funktion wird ausgeführt, die Zeit unmittelbar vor (\id{start}) und nach (\id{end}) der Ausführung wird gemessen. Die Laufzeit des Algorithmus ist nun gleich $\id{end} - \id{start}$.

Eine konkrete Implementation einer Klasse zur Messung der Laufzeit eines Algorithmus ist in \prettyref{lst:experiment} gegeben.

\begin{lstlisting}[caption={Implementation einer Klasse zur Ermittlung der Laufzeit eines Algorithmus.}, label=lst:experiment]
class experiment {
	std::function<void()> function;

	using clock_t = std::chrono::high_resolution_clock;

public:
	using duration_t = clock_t::duration;

	explicit experiment(std::function<void()> function)
		: function(std::move(function)) {};

	[[nodiscard]] duration_t run() const;
};


experiment::duration_t experiment::run() const {
	const auto start = clock_t::now();

	function();

	const auto end = clock_t::now();

	return duration_t{end - start};
}
\end{lstlisting}
\noindent
Die Laufzeit eines einfachen Algorithmus kann mit ihrer Hilfe durch
\begin{lstlisting}[numbers=none]
void a1() { ... }
const auto time = experiment(a1).run();
\end{lstlisting}
ermittelt werden, wobei die Zeitspanne in der für das System kleinstmöglichen Einheit angegeben ist (vgl. \cite[652]{ISO-C++17}). Auf den verwendeten Testsystem wird die Zeit in Nanosekunden gemessen, $1ns = 10^{-9}s = 0,000000001s$.

\paragraph{Algorithmen mit Eingabewerten} Der Konstruktor in der Klasse aus \prettyref{lst:experiment} erwartet als einzige Eingabe eine Variable des Typs \lstinline{std::function<void()>}, also eine Funktion ohne Eingabe- und Rückgabewerte. Dies ist der Fall um größtmögliche Flexibilität in der Verwendung der Testumgebung zu gewährleisten.

Die in dieser Arbeit behandelten Algorithmen haben alle einen oder mehrere Eingabewerte, sie erfüllen also nicht die Form wie sie vom Konstruktor erwartet wird. Um ein Experiment mit einer Funktion eines anderen Typs als \lstinline{void()} zu initialisieren wird ein \enquote{\emph{wrapper}} verwendet:

\begin{lstlisting}[numbers=none]
const size_t size = 1337;
void |\id{func}|(const size_t s) { ... }
const auto |\id{wrapper}| = [&]() { func(size); };
const auto time = experiment(wrapper).run();
\end{lstlisting}

Im obenstehenden Beispielcode wird ein Lambda-Ausdruck verwendet um eine \enquote{umwickelnde Funktion}, einen sogenannten \id{wrapper}, zu erstellen. Ein Aufruf von \id{wrapper} führt zum Aufruf der Funktion \id{func} mit dem Eingabeparameter \lstinline{size} bzw. 1337.

\section{Ermittlung}
\label{sec:funkterm}

Das Ziel ist es, eine Funktion aufzustellen, bzw. zu approximieren, welche die Laufzeit eines Algorithmus in Abhängigkeit der Eingabegröße darstellt (vgl. \cite[37]{mcg2012}). Um diesem Ziel nachzukommen gilt es die Eingabemenge in wachsende Untermengen aufzuteilen, diese Untermengen zu sortieren und die dafür benötigte Zeit (in Kombination mit der Größe der jeweiligen Untermenge) auszugeben.

Hierfür ist eine Klasse \lstinline{class benchmark} gegeben, die mit einer Eingabemenge, einem Sortieralgorithmus, einer Angabe zur Art der Ermittlung der Untermengen und der Anzahl der zu erstellenden Untermengen konstruiert wird.

\begin{lstlisting}[caption={Klasse zur Approximation einer Funktion der Laufzeit eines Algorithmus in Abhängigkeit der Eingabegröße.}, label=lst:simple-benchmark]
class benchmark {
public:
	using algorithm_t = sorters::sorter_t<sets::iterator_t>;

	struct result : public std::map<size_t, experiment::duration_t> {
	    // ...
	}

	// ...

	benchmark(sets::set_t set, algorithm_t algorithm, benchmark::step_type_t step_type, size_t total_chunks);

	[[nodiscard]] benchmark::result run() const;
};
\end{lstlisting}
\noindent
In \prettyref{lst:simple-benchmark} wird ein vereinfachter Einblick in eine Schnittstelle zu einem, diese Anforderungen erfüllenden, Mechanismus gegeben\footnote{Für eine vollständige Implementation siehe \crBenchmark~und \crBenchmarkImpl.}.

Die Funktion \lstinline{benchmark::run} retourniert eine Instanz der Klasse \lstinline{class benchmark::result} die wiederum eine Menge von Größenangaben und damit assoziierten Zeitangaben ist. Eine von dieser Funktion zurückgegebene Menge von Paaren hat beispielsweise die Form
\begin{equation*}
	\{
		(1, 0.0768125),
		(2, 0.104375),
		(3, 0.129938),
		(4, 0.170375),
		\ldots,
		(n, t)
	\}
\end{equation*}
Sie ist so interpretieren, dass der gegebene Algorithmus für das Sortieren einer Untermenge der Größe $n$ der gegebenen Menge $t$ Zeiteinheiten benötigt hat.

\paragraph{Art der Schrittgröße}

In \lstinline{benchmark::run} erfolgt also eine Teilung der ursprünglichen Eingabemenge in eine gewisse Anzahl von Untermengen. Die Art der Wachstumsrate der Größe dieser Untermengen wird im Konstruktor der Klasse festgelegt, wo entweder ein lineares oder ein quadratisches Wachstum gewählt werden kann (siehe \prettyref{fig:step-type-graphs}).

\begin{figure}[h]
	\centering
	\begin{subfigure}[T]{0.485\textwidth}
		\begin{tikzpicture}
			\begin{axis}[
				default, width=\textwidth,
				xmin=0, ymin=0, xmax=32,
				domain=0:32,
				legend pos=north west,
				xlabel={Index},
				ylabel={Größe},
			]
				\addplot[black] {(262144 / 128) * x};
				\addlegendentry{$l$};
				\addplot[black, thick] {262144 / 128^2) * x^2};
				\addlegendentry{$q$};
			\end{axis}
		\end{tikzpicture}
	\end{subfigure}
	\hfill
	\begin{subfigure}[T]{0.485\textwidth}
		\begin{tikzpicture}
			\begin{axis}[
				default, width=\textwidth,
				xmin=0, ymin=0, xmax=128,
				domain=0:128,
			]
				\addplot[black] {(262144 / 128) * x};
				\addplot[black, thick] {262144 / 128^2) * x^2};
			\end{axis}
		\end{tikzpicture}
	\end{subfigure}
	\caption{Graphen der Untermengengrößen bei einer gesamten Mengengröße von $2^{18}$, geteilt auf 128 Untermengen mit linearer ($l$) und quadratischer ($q$) Schrittgröße.}
	\label{fig:step-type-graphs}
\end{figure}

\section{Orchestrierung}

In den vorhergehenden Abschnitten wurde

\begin{itemize}
    \item eine Definition für einige Eingabemengen mit ihren korrespondierenden Generatoren gegeben (\prettyref{sec:runtime-inputs}).
    \item eine Testumgebung (\lstinline{class experiment}) zur Ermittlung der Laufzeit eines Algorithmus mit einer bestimmten Eingabemenge und Größe (\prettyref{sec:runtime-environment}).
    \item einen Mechanismus zur Laufzeitermittlung für steigende bzw. variierende Eingabegrößen (\lstinline{namespace benchmark}, \prettyref{sec:funkterm}).
\end{itemize}

Noch abgehend ist ein Mechanismus zur \emph{Orchestrierung} bzw. \emph{Instrumentalisierung} der bestehenden Teile. Genauer gilt es ein ausführbares Programm bereitzustellen, welches mithilfe der \lstinline{benchmark} Klasse für alle möglichen Kombinationen aus den Algorithmen und Eingabearten Benchmarkresultate ermittelt und diese ausgibt. Ebenfalls gilt es einen Mechanismus zur einfachen Kontrolle des Umfangs und der Präzision dieser Messungen bereitzustellen.

\ifndef{vwarelease}{
	\emph{Dieser Abschnitt ist zu erweitern. Kein Code, nur Referenz auf die ensprechenden Dateien --- die konkrete Implementation ist zu komplex, lohnt sich nicht zu erklären. Vielleicht sehr abstrakter Pseudocode? Eingehen auf die Wichtigkeit der task randomization zur Umgehung von branch prediction.}
}{}

\begin{figure}[htp]
	\centering
	\begin{tikzpicture}
		\begin{axis}[
			default, legend pos=north west, width=0.6\textwidth,
			xlabel={Größe},
			ylabel={Zeit},
		]
			\addplot[black] table	{data/supplementary/sequential-runs/run1/quick_random};
			\addlegendentry{1};
			\addplot[black, thick] table	{data/supplementary/sequential-runs/run8/quick_random};
			\addlegendentry{8};
		\end{axis}
	\end{tikzpicture}
	\caption{Zeit, die der Quicksort-Algorithmus jeweils bei der ersten und achten sequentiellen Ausführung zum Sortieren einer Liste benötigt.}
\end{figure}

\input{figures/benchmark-file-structure}

\prettyref{fig:benchmark-file-structure} demonstriert beispielhaft die Art und Weise mit welcher die ermittelten Daten im Dateisystem abgelegt werden.
