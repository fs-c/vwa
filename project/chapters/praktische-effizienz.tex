\chapter{Laufzeitermittlung als Effizienzangabe}
\label{cha:praktische-effizienz}

In diesem Kapitel wird eine Methode zur Ermittlung der Laufzeit von Algorithmen dargestellt.

Für konkrete Implementationen und Quellcode-Beispiele wird die Programmiersprache C++ (\cite{ISO-C++17}, \enquote{C++17}) verwendet.

\ifndef{vwarelease}{
\emph{Hier sind \citetitle{joh2002} (\cite{joh2002}) und \citetitle{mcg2012} (\cite{mcg2012}) wichtig. \cite[83]{sha2011} kann als Argumentation für das ausgeprägte Verwenden der \emph{Standard Library} ausgelegt werden nachdem hier potentielle Vorurteile bzw. Ungleichheiten bei der Programmierung de facto wegfallen.}

\emph{Der Werdegang der Empirie in den Computerwissenschaften ist nicht unspannend: Zu Zeiten von \cite{joh2002} war die empirische Analyse als Feld offenbar noch bei weitem nicht so weit fortgeschritten und verbreitet wie im Erscheinungsjahr von \cite{mcg2012}. Beide beinhalten weitgehend äquivalente Kernaussagen, aber erstere Publikation ist noch bei weitem unausgereifter als letztere. 
}}{}

\section{Vorgehensweise}

Es gilt die Laufzeit eines Algorithmus zu ermitteln und diese annähernd als Funktion $T(n)$ (wobei $T(n)$ die Zeit und $n$ die Eingabegröße ist) darzustellen. Das Ziel deckt sich also mit jenem der asymptotischen Analyse aus \prettyref{cha:asymptotic-analysis}. Genauer gilt es, ebenfalls wie in der asymptotischen Analyse, eine solche Funktion für diverse Arten von Eingabemengen zu ermitteln (\cite[27]{mcg2012}).

Nach \cite[10]{mcg2012} kann \enquote{the experimental process} im Kontext der empirischen Algorithmusanalyse im Wesentlichen grob in die Formulierung einer Frage, die Bereitstellung einer, die Frage behandelnden, Testumgebung bzw. eines Testprogramms und die Ausführung des Testprogramms aufgegliedert werden.

Eine grobe Formulierung der Frage ergibt sich schon aus der vorhergehenden Einleitung dieses Kapitels:

\spaced{\enquote{Wie viel Zeit benötigt ein Sortieralgorithmus um Eingabemengen verschiedener Art und Größe in eine sortierte Ausgabemenge zu überführen?}}

Um diese Frage zu konkretisieren und umsetzbar zu machen, gilt es nunmehr noch die verschiedenen Arten und Größen der Eingabemengen zu definieren, dies geschieht in \prettyref{sec:runtime-inputs}.

Eine Testumgebung welche die Frage behandelt wird in \prettyref{sec:runtime-environment} bereitgestellt.

\section{Eingabemengen}
\label{sec:runtime-inputs}

Für die Ermittlung der praktischen Effizienz werden sortierte, invertierte und zufällig geordnete\nocit Eingabemengen verwendet. Um diese Mengen zu generieren werden die Funktionen \lstinline{sets::sorted}, \lstinline{sets::inverted} und \lstinline{sets::random} verwendet.

\begin{lstlisting}[caption=Funktionen welche Mengen der verwendeten Eingabemengearten generieren.]
namespace sets {
    using set_t = std::vector<int>;

    // ...
}

sets::set_t sets::sorted(const size_t size) {
	auto set = set_t(size);

	std::iota(set.begin(), set.end(), 1);

	return set;
}

sets::set_t sets::inverted(const size_t size) {
	auto set = set_t(size);

	std::iota(std::rbegin(set), std::rend(set), 1);

	return set;
}

sets::set_t sets::random(const size_t size) {
	auto set = sorted(size);

	utils::random_shuffle(set.begin(), set.end());

	return set;
}
\end{lstlisting}

(Die Funktion \lstinline{utils::random_shuffle}, welche für das Generieren der zufällig geordneten Menge verwendet wird, verwendet den Mersenne-Twister Algorithmus um hochwertige Pseudozufallszahlen zu generieren und damit die Eingabemenge \enquote{durchzumischen}. Siehe \prettyref{lst:random-shuffle} für die verwendete Implementation der Funktion.)

Eine ausführlichere Auswahl an Eingangsmengen welche an einen sie bearbeitenden Algorithmen angepasst ist --- wie sie für eine eingehende Analyse eines einzelnen Algorithmus angebracht wäre (vgl. \cite[27ff]{mcg2012}) --- würde das allgemeiner gesetzte Ziel dieser Arbeit verfehlen.

\section{Testumgebung}
\label{sec:runtime-environment}

Es gilt die Zeit, welche eine Funktion für die vollständige Ausführung benötigt, zu messen. Die Funktion wird ausgeführt, die Zeit unmittelbar vor (\id{start}) und nach (\id{end}) der Ausführung wird gemessen. Die Laufzeit des Algorithmus ist nun gleich $\id{end} - \id{start}$.

Eine konkrete Implementation einer Klasse zur Messung der Laufzeit eines Algorithmus ist in \prettyref{lst:experiment} gegeben.

\begin{lstlisting}[caption={Implementation einer Klasse zur Ermittlung der Laufzeit eines Algorithmus.}, label=lst:experiment]
class experiment {
	std::function<void()> function;

	using clock_t = std::chrono::high_resolution_clock;

public:
	using duration_t = clock_t::duration;

	explicit experiment(std::function<void()> function)
		: function(std::move(function)) {};

	[[nodiscard]] duration_t run() const;
};


experiment::duration_t experiment::run() const {
	const auto start = clock_t::now();

	function();

	const auto end = clock_t::now();

	return duration_t{end - start};
}
\end{lstlisting}
\noindent
Die Laufzeit eines einfachen Algorithmus kann mit ihrer Hilfe durch
\begin{lstlisting}[numbers=none]
void a1() { ... }
const auto time = experiment(a1).run();
\end{lstlisting}
ermittelt werden, wobei die Zeitspanne in der für das System kleinstmöglichen Einheit angegeben ist (vgl. \cite[652]{ISO-C++17}). Auf den verwendeten Testsystem wird die Zeit in Nanosekunden gemessen, $1ns = 10^{-9}s = 0,000000001s$.

\paragraph{Algorithmen mit Eingabewerten} Der Konstruktor in der Klasse aus \prettyref{lst:experiment} erwartet als einzige Eingabe eine Variable des Typs \lstinline{std::function<void()>}, also eine Funktion ohne Eingabe- und Rückgabewerte. Dies ist der Fall um größtmögliche Flexibilität in der Verwendung der Testumgebung zu gewährleisten.

Die in dieser Arbeit behandelten Algorithmen haben alle einen oder mehrere Eingabewerte, sie erfüllen also nicht die Form wie sie vom Konstruktor erwartet wird. Um ein Experiment mit einer Funktion eines anderen Typs als \lstinline{void()} zu initialisieren wird ein \enquote{\emph{wrapper}} verwendet:

\begin{lstlisting}[numbers=none]
const size_t size = 1337;
void |\id{func}|(const size_t s) { ... }
const auto |\id{wrapper}| = [&]() { func(size); };
const auto time = experiment(wrapper).run();
\end{lstlisting}

Im obenstehenden Beispielcode wird ein Lambda-Ausdruck verwendet um eine \enquote{umwickelnde Funktion} \id{wrapper} zu erstellen. Ein Aufruf von \id{wrapper} führt zum Aufruf der Funktion \id{func} mit dem Eingabeparameter \lstinline{size} bzw. 1337.

\section{Ermittlung}
\label{sec:funkterm}

Das Ziel ist es, eine Funktion in Abhängigkeit der Eingabegröße aufzustellen bzw. zu approximieren, welche die Laufzeit eines Algorithmus darstellt (vgl. \cite[37]{mcg2012}). Um diesem Ziel nachzukommen gilt es die Eingabemenge in immer größer werdende Untermengen aufzuteilen, diese Untermengen zu sortieren und die dafür benötigte Zeit zusammen mit der Größe der jeweiligen Untermenge auszugeben. 

Hierfür ist eine Klasse \lstinline{class benchmark} gegeben, die mit einer Eingabemenge, einem Sortieralgorithmus, einer Angabe zur Art der Ermittlung der Untermengen und der Anzahl der zu erstellenden Untermengen konstruiert wird.

\begin{lstlisting}[caption={Klasse zur Approximation einer Funktion der Laufzeit eines Algorithmus in Abhängigkeit der Eingabegröße.}, label=lst:simple-benchmark]
class benchmark {
public:
	using algorithm_t = sorters::sorter_t<sets::iterator_t>;

	struct result : public std::map<size_t, experiment::duration_t> {
	    // ...
	}

	// ...

	benchmark(sets::set_t set, algorithm_t algorithm, benchmark::step_type_t step_type, size_t total_chunks);

	[[nodiscard]] benchmark::result run() const;
};
\end{lstlisting}
\noindent
In \prettyref{lst:simple-benchmark} wird ein vereinfachter Einblick in eine Schnittstelle zu einem, diese Anforderungen erfüllenden, Mechanismus gegeben\footnote{Für eine vollständige Implementation siehe \crBenchmark~und \crBenchmarkImpl.}. Die Funktion \lstinline{benchmark::run} ist hier das zentrale Element: Sie erstellt

% Werte dieser Funktion der praktischen Effizienz können mithile der Funktion \lstinline{benchmark::run} in \prettyref{lst:benchmark} ermittelt werden.


% Die Funktion \lstinline{benchmark::run} nimmt als Eingabeparameter einen Algorithmus, eine Menge und die Anzahl der Untermengen.

% Nach Ausführung von \lstinline{benchmark::run} werden (sequentiell) \emph{überlappende Untermengen} der Eingabemenge erstellt. Für jede Untermenge wird eine Instanz der Experimentklasse (siehe \prettyref{sec:runtime-environment}) erstellt und ausgeführt, somit wird für jede Untermenge die Laufzeit des Algorithmus ermittelt.

% Als Rückgabewert liefert sie Wertepaare in einem \emph{Container} vom Typ \lstinline{std::map<size_t, experiment::time_t>}. Dieser assoziative Container enthält eine geordnete Menge von Schlüssel-Wert-Paaren wobei die Schlüssel die Größe der jeweils betrachteten und sortierten Untermenge, und die Werte die jeweils benötigten Zeiten darstellen. Die Werte können nun wie in \prettyref{subfig:funkterm-beispieldaten} ausgegeben, oder wie in \prettyref{subfig:funkterm-beispielgraph} als Graph dargestellt werden.

% \input{figures/function-determination-raw-data}

% Der Prägnanz halber wird es hilfreich sein einige der im vorhergehenden Quellcode vorkommende Variablennamen Pseudonyme zu geben. Ebenfalls werden dem Verständnis dienende \enquote{gedachte Variablen} benannt. So gilt folgend
% %
% \begin{equation*}
% 	\begin{aligned}
% 		t &= \text{\lstinline{total_chunks}, Anzahl der Untermengen} \\
% 		s &= \text{\lstinline{set_size}, Größe der Eingabemenge} \\
% 		c &= \text{\lstinline{chunk_size}, \enquote{Schrittgröße}} \\
% 		t &= \text{Anzahl der Untermengen} \\
% 		U_i &= \text{$i$-te Untermenge} \\
% 		n_i &= \text{Größe von $U_i$} \\
% 	\end{aligned}
% \end{equation*}
% %
% Die Anzahl der Untermengen und die Größe der Eingabemenge ist bekannt. Um nun die Größe der jeweilige Untermengen zu berechnen gilt
% \begin{equation*}
% 	n_i = c \cdot i \quad \text{für alle $0 < i \leq \frac{s}{c} \in \mathbb{N}$}
% \end{equation*}
% für
% \begin{equation*}
% 	c = \begin{cases}
% 		1 & \text{für $s \leq t$}\\
% 		\frac{s}{t} & \text{für $s > t$}
% 	\end{cases} \in \mathbb{N}
% \end{equation*}

% Sollen aus einer Eingangsmenge der Größe 100 insgesamt 30 Untermengen generiert werden, gilt $c = 3$ (nicht $3,\overline{3}$ nachdem $c \in \mathbb{N}$) und somit $n_1 = 3, n_2 = 6, \ldots, n_{33} = 99$. \emph{Hier gilt also, dass das größtmögliche $i \neq t$!} Es werden in manchen Fällen mehr Untermengen generiert als angefordert, wenn dies möglich ist. Im gegebenen Verwendungsfall ist das vorteilhaft und Absicht, der Umstand ist dennoch erwähnenswert um Verwirrung vorzubeugen.

\section{Orchestrierung}

In den vorhergehenden Abschnitten wurde

\begin{itemize}
    \item eine Definition für einige Eingabemengen mit ihren korrespondierenden Generatoren gegeben (\prettyref{sec:runtime-inputs}).
    \item eine Testumgebung (\lstinline{class experiment}) zur Ermittlung der Laufzeit eines Algorithmus mit einer bestimmten Eingabemenge und Größe (\prettyref{sec:runtime-environment}).
    \item einen Mechanismus zur Laufzeitermittlung für steigende bzw. variierende Eingabegrößen (\lstinline{namespace benchmark}, \prettyref{sec:funkterm}).
\end{itemize}

Noch abgehend ist ein Mechanismus zur \emph{Orchestrierung} bzw. \emph{Instrumentalisierung} der bestehenden Teile. Genauer gilt es ein ausführbares Programm bereitzustellen, welches

\begin{itemize}
    \item mithilfe von \lstinline{benchmark::run} für alle möglichen Kombinationen aus den Algorithmen und Eingabearten Wertepaare ermittelt, und diese Wertepaare in weiterverarbeitbarer Form ausgibt.

    \item einen Mechanismus zur Kontrolle des Umfangs und der Präzision von Messungen bietet.
\end{itemize}

\begin{lstlisting}[label=lst:main, caption={Die \lstinline{main} Funktion des zur Ermittlung der praktischen Effizienz verwendeten Programms.}]
int main(int, char *argv[]) {
	config cfg{argv};

	if (cfg.should_exit) {
		return 1;
	}

	auto sorters = std::map<const char *, algorithm_t>{
		{"quick",       sorters::quick<sets::iterator_t>},
		{"heap",        sorters::heap<sets::iterator_t>},
		{"merge",       sorters::merge<sets::iterator_t>},
		{"insertion",   sorters::insertion<sets::iterator_t>},
	};

	const size_t set_size = cfg.sample_size;

	auto sets = std::map<const char *, sets::set_t>{
		{"sorted",      sets::sorted(set_size)},
		{"random",      sets::random(set_size)},
		{"inverted",    sets::inverted(set_size)},
	};

	printf("sorting %d elements\n", set_size);

	for (auto [sorter_name, sorter] : sorters) {
		for (auto [set_name, set] : sets) {
			benchmark::write(cfg.output, sorter_name, set_name,
				benchmark::run(sorter, set, cfg.total_chunks));
		}
	}

	return 0;
}
\end{lstlisting}

\prettyref{lst:main} zeigt eine Implementation der obigen Anforderungen. Die Algorithmen werden gesammelt und mit einem ausgebbaren Namen assoziiert, ebenso die Eingabemengen. Jeder Algorithmus wird mit jeder Eingabemenge kombiniert und an \lstinline{benchmark::run} übergeben, das Ergebnis wird durch \lstinline{benchmark::write} (siehe \prettyref{lst:benchmark-write}) abgelegt.

\prettyref{fig:benchmark-file-structure} demonstriert beispielhaft die Art und Weise mit welcher die Funktion in \prettyref{lst:main} Daten ablegt.

\input{figures/benchmark-file-structure}
